// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var ChannelApi$BsDiscord = require("./api/ChannelApi.bs.js");
var PayloadTypes$BsDiscord = require("./PayloadTypes.bs.js");
var PayloadParser$BsDiscord = require("./PayloadParser.bs.js");
var PresenceStore$BsDiscord = require("./state/PresenceStore.bs.js");
var WebsocketClient$BsDiscord = require("./WebsocketClient.bs.js");

var Unsupported = Caml_exceptions.create("Gateway-BsDiscord.Unsupported");

function identify(param, token) {
  return WebsocketClient$BsDiscord.Websocket[/* send */8](param[/* ws */0], JSON.stringify({
                  op: PayloadTypes$BsDiscord.opCodeToJs(/* Identify */2),
                  d: {
                    token: token,
                    properties: {
                      $os: "darwin",
                      $browser: "bs-discord",
                      $device: "bs-discord"
                    }
                  }
                }));
}

function resume(param, token) {
  var match = param[/* lastSequenceId */2][0];
  return WebsocketClient$BsDiscord.Websocket[/* send */8](param[/* ws */0], JSON.stringify({
                  op: PayloadTypes$BsDiscord.opCodeToJs(/* Resume */5),
                  d: {
                    token: token,
                    session_id: param[/* sessionId */1],
                    seq: match !== undefined ? match : null
                  }
                }));
}

function startHeartbeat(ws, lastSequenceId, payload) {
  setInterval((function (param) {
          console.log("heartbeat");
          var match = lastSequenceId[0];
          return WebsocketClient$BsDiscord.Websocket[/* send */8](ws, JSON.stringify({
                          op: PayloadTypes$BsDiscord.opCodeToJs(/* Heartbeat */1),
                          d: match !== undefined ? Caml_option.valFromOption(match) : null
                        }));
        }), payload[/* heartbeatInterval */0]);
  return /* () */0;
}

function handleMessage(param, message) {
  if (typeof message === "number") {
    return /* () */0;
  } else if (message.tag) {
    var match = message[0];
    if (typeof match === "number") {
      return /* () */0;
    } else {
      switch (match.tag | 0) {
        case 0 : 
            param[/* sessionId */1][0] = match[0][/* sessionId */0];
            return /* () */0;
        case 1 : 
            var match$1 = match[0][/* presences */8];
            if (match$1 !== undefined) {
              return PresenceStore$BsDiscord.updatePresences(match$1);
            } else {
              return /* () */0;
            }
        case 2 : 
            var message$1 = match[0];
            if ("ping".indexOf(message$1[/* content */4]) !== -1) {
              ChannelApi$BsDiscord.createMessage(message$1[/* channelId */1], "pong");
              return /* () */0;
            } else {
              return 0;
            }
        case 3 : 
            return PresenceStore$BsDiscord.updatePresence(match[0]);
        case 4 : 
            return /* () */0;
        
      }
    }
  } else {
    return startHeartbeat(param[/* ws */0], param[/* lastSequenceId */2], message[0]);
  }
}

function createSocket(token, onOpen, onMessage, onError, onClose, param) {
  var state_000 = /* ws */WebsocketClient$BsDiscord.Websocket[/* make */2](undefined, "wss://gateway.discord.gg/?v=6&encoding=json");
  var state_001 = /* sessionId : record */[/* contents */undefined];
  var state_002 = /* lastSequenceId : record */[/* contents */undefined];
  var state = /* record */[
    state_000,
    state_001,
    state_002
  ];
  WebsocketClient$BsDiscord.Websocket[/* onOpen */4](state_000, (function (e) {
          if (onOpen !== undefined) {
            Curry._1(onOpen, e);
          }
          var match = state_001[0];
          if (match !== undefined) {
            return resume(state, token);
          } else {
            return identify(state, token);
          }
        }));
  WebsocketClient$BsDiscord.Websocket[/* onMessage */7](state_000, (function (e) {
          console.log(e.data);
          var json = JSON.parse(e.data);
          var match = Json_decode.field("s", (function (param) {
                  return Json_decode.optional(Json_decode.$$int, param);
                }), json);
          if (match !== undefined) {
            state_002[0] = match;
          }
          var message = PayloadParser$BsDiscord.parseSocketData(json);
          handleMessage(state, message);
          if (onMessage !== undefined) {
            Curry._1(onMessage, message);
          }
          return /* () */0;
        }));
  WebsocketClient$BsDiscord.Websocket[/* onError */5](state_000, (function (e) {
          if (onError !== undefined) {
            Curry._1(onError, e);
          }
          return WebsocketClient$BsDiscord.Websocket[/* close */3](undefined, undefined, state_000);
        }));
  return WebsocketClient$BsDiscord.Websocket[/* onClose */6](state_000, (function (e) {
                if (onClose !== undefined) {
                  return Curry._1(onClose, e);
                } else {
                  return /* () */0;
                }
              }));
}

exports.Unsupported = Unsupported;
exports.identify = identify;
exports.resume = resume;
exports.startHeartbeat = startHeartbeat;
exports.handleMessage = handleMessage;
exports.createSocket = createSocket;
/* WebsocketClient-BsDiscord Not a pure module */
